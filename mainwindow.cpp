// checksum 0xa193 version 0x30001
/*
  This file was generated by the Mobile Qt Application wizard of Qt Creator.
  MainWindow is a convenience class containing mobile device specific code
  such as screen orientation handling.
  It is recommended not to modify this file, since newer versions of Qt Creator
  may offer an updated version of it.
*/

#include "mainwindow.h"
#include "ui_mainwindow.h"

#include <QtCore/QCoreApplication>
#include <QDebug>
#include <QDir>
#include <QMouseEvent>
#include <QPair>
#include <QPixmap>
#include <QMessageBox>
#include <QString>
#include <QList>


#include <QPainter>
#include <QScrollBar>

#define NOTES_PER_PAGE 4
#define NOTES_PER_ROW  2
#define DYNAMIC_HEIGHT 260

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui->setupUi(this);

#if defined(Q_WS_MAC)
    _loadDir = "/Users/sebastian/Desktop/notes/";
    // startI = 2 um . und .. auszuschlieﬂen
    _startI = 2;
    _dir = "/";
#else
    // überprüfen, ob eine speicherkarte im Gerät ist
    if (QDir("e:\\").exists()) {
        _loadDir = "e:\\Development\\notes\\";
    } else {
        _loadDir = "c:\\Development\\notes\\";
    }
    _startI = 0;
    _dir = "\\";
#endif

    _rowCounter     = 0;
    _columnCounter  = 0;
    _pageCounter    = 1;
    _itemCounter    = 0;
    _currentPage    = 0;
    _lastPresspoint = -1;

    _gridLayout = (QGridLayout*)ui->noteWidget->layout();
    _gridLayout->setAlignment(Qt::AlignTop);
    _gridLayout->setVerticalSpacing(46);

    ui->menuWidget->setVisible(false);
    ui->menuWidget->setEnabled(false);

    // to recieve QMouseEvents through the scrollArea and its viewport
    ui->scrollArea->viewport()->setMouseTracking(true);

    loadNotes();
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::mouseMoveEvent(QMouseEvent *event)
{
    // fake a mousePressEvent because the real one
    // could be caught by a button
    if (_lastPresspoint == -1)
    {
        _lastPresspoint = event->globalPos().y();
        _lastScrollBarPos = ui->scrollArea->verticalScrollBar()->value();
    } else {
        int scrollPos = _lastScrollBarPos - (event->globalPos().y() - _lastPresspoint);
        const int min = ui->scrollArea->verticalScrollBar()->minimum();
        const int max = ui->scrollArea->verticalScrollBar()->maximum();

        // consider the limits
        if (scrollPos > max)
        {
            scrollPos = max;
        } else if (scrollPos < min) {
            scrollPos = min;
        }

        ui->scrollArea->verticalScrollBar()->setValue(scrollPos);
    }
}

void MainWindow::mouseReleaseEvent(QMouseEvent *)
{
    _lastPresspoint = -1;
}

void MainWindow::resetLastPresspoint()
{
    _lastPresspoint = -1;
}

void MainWindow::on_addButton_clicked()
{
    qDebug() << "[QUICK ADD NEW NOTE]";

    NoteButton * nb = new NoteButton();
    addNoteToGrid(nb);
    doConnect(nb);
}

void MainWindow::doConnect(NoteButton *b)
{
    qDebug() << "[connecting NoteButton]" << b;
    connect(b, SIGNAL(updateMe(NoteButton *)), this, SLOT(updateNoteButtonIcon(NoteButton *)));
    connect(b, SIGNAL(deleteMe(NoteButton *)), this, SLOT(deleteNoteButton(NoteButton*)));
    connect(b, SIGNAL(releaseEvent()), this, SLOT(resetLastPresspoint()));
}

void MainWindow::addNoteToGrid(NoteButton *b){
    qDebug() << "[ADDING NOTE TO GRID]" << b;

    qDebug() << _gridLayout->count();
    int row = _gridLayout->count() / 2;
    int column = 0;
    if (_gridLayout->count() % 2 == 1)
    {
        column = 1;
    }

    _gridLayout->addWidget(b, row, column++);

    if (!_noteButtonList.contains(b))
    {
        _noteButtonList.append(b);
        _noteButtonGroup.addButton(b, _noteButtonList.size() - 1);
    }

    updateMinimumHeight();
    update();
}

void MainWindow::updateMinimumHeight()
{
    qDebug() << "[UPDATING MINIMUM HEIGHT] " << _noteButtonList.size();

    if(_noteButtonList.size() % 2 == 0){
        ui->scrollAreaWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.size()/2));
        ui->noteWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.size()/2));
    }else{
        ui->scrollAreaWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.size()/2) + DYNAMIC_HEIGHT);
        ui->noteWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.size()/2) + DYNAMIC_HEIGHT);
    }
}

void MainWindow::updateNoteButtonIcon(NoteButton * b){
    qDebug() << "[SLOT: updating NoteButton]" << b;
    b->updateIcon();
}

void MainWindow::on_menuButton_clicked()
{
    //ui->addButton->setVisible(false);

    if(_noteButtonGroup.checkedId() == -1)
    {
        ui->sendButton_menu->setDisabled(true);
        ui->delButton_menu->setDisabled(true);
    } else {
        ui->sendButton_menu->setEnabled(true);
        ui->delButton_menu->setEnabled(true);
    }

    ui->menuWidget->setVisible(true);
    ui->menuWidget->setEnabled(true);
}

void MainWindow::on_menuCloseButton_clicked()
{
    //ui->addButton->setVisible(true);
    ui->menuWidget->setVisible(false);
    ui->menuWidget->setEnabled(false);
}

void MainWindow::on_quitButton_menu_clicked()
{
    qApp->quit();
}

void MainWindow::loadNotes()
{
    qDebug() << "[INFO] loading notes";
    if (!QDir(_loadDir).exists())
    {
        QDir().mkdir(_loadDir);
    }

    QStringList dirEntrys = QDir(_loadDir).entryList();
    QString tempDir;
    QPixmap pixmap(360, 640);

    for(int i = _startI; i < dirEntrys.size(); i++)
    {
        tempDir = dirEntrys.at(i);

        // get first page of the note
        // if there is no first page create an empty pixmap
        QFile firstPage(_loadDir + tempDir + _dir + tempDir + "_0.png");
        if (firstPage.exists())
        {
            pixmap.fill(Qt::white);
            QPainter painter(&pixmap);
            QPixmap temp = QPixmap(_loadDir + tempDir + _dir + tempDir + "_0.png");
            painter.drawPixmap(QPoint(0, 0), temp);
        } else {
            pixmap.fill(Qt::transparent);
        }

        NoteButton * button = new NoteButton(pixmap, dirEntrys.at(i));
        addNoteToGrid(button);
        doConnect(button);
    }
}

void MainWindow::on_sendButton_menu_clicked()
{
    _noteButtonList.at(_noteButtonGroup.checkedId())->getNotePainterWidget()->sendNote();
    _noteButtonList.at(_noteButtonGroup.checkedId())->setNotePainterWidget(NULL);

    on_menuCloseButton_clicked();
}

void MainWindow::showExpanded()
{
#ifdef Q_WS_MAC
    show();
#else
    showFullScreen();
#endif
}

void MainWindow::on_helpButton_menu_clicked()
{
    HelpWidget * hw = new HelpWidget();
    hw->showExpanded();
}

void MainWindow::updateGrid()
{
    // Clearing the gridLayout
    QLayoutItem *child;
    while ((child = _gridLayout->takeAt(0)) != 0) {
        _gridLayout->removeItem(_gridLayout->takeAt(0));
        delete child;
    }

    int d = _noteButtonList.size();
    for(int i = 0; i < d; i++)
    {
        addNoteToGrid(_noteButtonList.at(i));
    }

    updateMinimumHeight();
}

void MainWindow::deleteNoteButton(NoteButton * b)
{
    qDebug() << "[DELETE SIGNAL]" << b;
    QString deleteFolder = _loadDir + b->getFileName();
    QStringList deleteFiles = QDir(deleteFolder).entryList();

    // delete files (only empty folders can be deleted)
    for(int i = _startI; i < deleteFiles.size(); i++)
    {
        QDir().remove(deleteFolder + _dir + deleteFiles.at(i));
    }

    // after all files are deleted the folder can be removed
    QDir().rmdir(deleteFolder);

    for(int i = 0; i < _noteButtonList.size(); i++)
    {
        _noteButtonGroup.removeButton(_noteButtonList.at(i));
    }

    _noteButtonList.removeOne(b);

    for(int i = 0; i < _noteButtonList.size(); i++)
    {
        _noteButtonGroup.addButton(_noteButtonList.at(i), i);
    }

    updateGrid();
    b->deleteLater();
}

void MainWindow::on_delButton_menu_clicked()
{
    qDebug() << "[DELETE]" << _noteButtonGroup.checkedButton();

    deleteNoteButton(_noteButtonList.at(_noteButtonGroup.checkedId()));
    on_menuCloseButton_clicked();
}

void MainWindow::on_addButton_menu_clicked()
{
    on_addButton_clicked();
    on_menuCloseButton_clicked();
}
