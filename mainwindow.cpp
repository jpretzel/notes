// checksum 0xa193 version 0x30001
/*
  This file was generated by the Mobile Qt Application wizard of Qt Creator.
  MainWindow is a convenience class containing mobile device specific code
  such as screen orientation handling.
  It is recommended not to modify this file, since newer versions of Qt Creator
  may offer an updated version of it.
*/

#include "mainwindow.h"
#include "ui_mainwindow.h"

#include <QtCore/QCoreApplication>

#include <QSystemInfo>

#include <QDebug>
#include <QDir>
#include <QGestureEvent>
#include <QSwipeGesture>
#include <QPair>
#include <QPixmap>
#include <QMessageBox>
#include <QString>

#include <qmessageservice.h>
#include <QContactManager>
#include <QList>
#include <QContact>
#include <QContactDetail>

#define NOTES_PER_PAGE 4
#define NOTES_PER_ROW  2
#define DYNAMIC_HEIGHT 289

QTM_USE_NAMESPACE

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    QSystemInfo info(this);
    qDebug() << info.currentLanguage();

    _rowCounter     = 0;
    _columnCounter  = 0;
    _pageCounter    = 1;
    _itemCounter    = 0;
    _currentPage    = 0;
    _p1             = QPoint(-1, -1);
    _p2             = QPoint(-1, -1);

    _gridLayout = (QGridLayout*)ui->noteWidget->layout();

    ui->menuWidget->setVisible(false);
    ui->menuWidget->setEnabled(false);

    // for swipeGesture
    setMouseTracking(true);
    loadNotes();
    displayPage(0);
}

MainWindow::~MainWindow()
{
    delete ui;
}

bool MainWindow::event(QEvent *event)
{
    /*if (event->type() == QEvent::KeyPress){
        displayPage(_currentPage + 1);
    }*/
    if (event->type() == QEvent::Gesture)
        //return gestureEvent(static_cast<QGestureEvent*>(event));
        qDebug("hello from QGestureEvent");
    return QWidget::event(event);
}

void MainWindow::mouseMoveEvent(QMouseEvent *event)
{
    // only set _p1 when it was invalid before
    // bug in mac osx because it catches
    // a moveEvent when the mouse hovers the App the first time
    if (_p1.x() == -1)
        _p1 = event->pos();
}

void MainWindow::mouseReleaseEvent(QMouseEvent *event)
{
    _p2 = event->pos();

    if ( _p1.x() != -1 && abs(_p1.x() - _p2.x()) > 70 )
    {
        if (_p1.x() > _p2.x())
            displayPage(_currentPage + 1);
        else
            displayPage(_currentPage - 1);
    }

    // ivalidate points
    _p1 = QPoint(-1, -1);
    _p2 = QPoint(-1, -1);
}

void MainWindow::on_addButton_clicked()
{
    qDebug() << "[QUICK ADD NEW NOTE]";

    NoteButton * nb = new NoteButton();
    addNoteToGrid(nb);
}

void MainWindow::addNoteToGrid(NoteButton *b){
    qDebug() << "[ADDING NOTE TO GRID]" << b;

    int row, column, items;

    // ungerade anzahl, platz in reihe noch frei
    if(_gridLayout->children().count() % 2){
        row = _gridLayout->columnCount();
        column = 1;
    }else{
        row = _gridLayout->columnCount() + 1;
        column = 0;
    }

    _gridLayout->addWidget(b, row, column, Qt::AlignTop);

    ui->scrollAreaWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.length()/2));
    ui->noteWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.length()/2));
}

void MainWindow::displayPage(int page){

}

void MainWindow::clearPage(){
    // Delete
    /*while(_noteList.size() > 0){
        delete(_noteList.takeFirst());
    }*/
}

void MainWindow::on_menuButton_clicked()
{
    //ui->addButton->setVisible(false);
    ui->menuWidget->setVisible(true);
    ui->menuWidget->setEnabled(true);
}

void MainWindow::on_menuCloseButton_clicked()
{
    //ui->addButton->setVisible(true);
    ui->menuWidget->setVisible(false);
    ui->menuWidget->setEnabled(false);
}

void MainWindow::paintEvent(QPaintEvent *){
    /*for(int i=0; i < _noteButtonList.size(); i++){
        _noteButtonList.at(i)->updateIcon();
    }*/
}

void MainWindow::on_quitButton_menu_clicked()
{
    exit(0);
}

void MainWindow::updateNoteIcons(){
}

void MainWindow::loadNotes()
{
    QString loadDir;
    QString dir;
#if defined(Q_WS_MAC)
    loadDir = "/Users/jan/Desktop/notes/";
    // startI = 2 um . und .. auszuschlieﬂen
    int startI = 2;
    dir = "/";
#else
    // ¸berpr¸fen, ob eine speicherkarte im Ger‰t ist
    if (QDir("e:\\").exists()) {
        loadDir = "e:\\Development\\notes\\";
    } else {
        loadDir = "c:\\Development\\notes\\";
    }
    int startI = 0;
    dir = "\\";
#endif

    if (!QDir(loadDir).exists())
    {
        QDir().mkdir(loadDir);
    }

    QStringList dirEntrys = QDir(loadDir).entryList();
    QString tempDir;
    QPixmap pixmap;

    for(int i = startI; i < dirEntrys.size(); i++)
    {
        tempDir = dirEntrys.at(i);

        // die erste Seite der Note holen
        // sollte diese nicht existieren weil es sich um eine leere Seite handelt
        // muss eine leere Pixmap erstellt und ¸bergeben werden
        QFile firstPage(loadDir + tempDir + dir + tempDir + "_0.png");
        if (firstPage.exists())
        {
            pixmap = QPixmap(loadDir + tempDir + dir + tempDir + "_0.png");
        } else {
            pixmap = QPixmap(360, 640);
            pixmap.fill(Qt::transparent);
        }

        // auslagern
        //NoteButton * nb = new NoteButton(pixmap, dirEntrys.at(i));
        //addNoteToGrid(nb);
        //_noteData.append(new QPair<QPixmap, QString>(pixmap, dirEntrys.at(i)));
        _noteButtonList.append(new NoteButton(pixmap, dirEntrys.at(i)));
    }

    int row     = 0;
    int column  = 0;
    for(int i = 0; i < _noteButtonList.length(); i++){
        if(column > 1){
            row++;
            column = 0;
        }
        _gridLayout->addWidget(_noteButtonList.at(i), row, column++, Qt::AlignTop);
    }

    ui->scrollAreaWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.length()/2));
    ui->noteWidget->setMinimumHeight(DYNAMIC_HEIGHT * (_noteButtonList.length()/2));

    update();
}

void MainWindow::on_sendButton_menu_clicked(){
    qDebug() << "[EMAIL]";

    QStringList availableManagers = QContactManager::availableManagers();

        for(int managerIdx = 0; managerIdx < availableManagers.count(); managerIdx++) {
            QContactManager * manager = new QContactManager(availableManagers.at(managerIdx));

            if(manager) {
                QList<QContact> contacts = manager->contacts();
                for(int i = 0; i < contacts.count(); i++){
                    qDebug() << contacts.at(i);
                }
                delete manager;
            }
        }

    QMessageService * service = new QMessageService();
    QMessageAccount * account = new QMessageAccount();

    QMessage msg;
    msg.setType(QMessage::Email);

    // Setting the stored EmailAdress as sender.
    msg.setParentAccountId(account->defaultAccount(QMessage::Email));

    msg.setTo(QMessageAddress(QMessageAddress::Email, "sebastian.ullrich@deepsource.de"));
    msg.setSubject("notes for you :)");

    if(service->send(msg)){
        qDebug() << "[EMAIL] Email sent successfully!";
    }else qDebug() << "[EMAIL] Unable to send Email!";
}


void MainWindow::setOrientation(ScreenOrientation orientation)
{
#if defined(Q_OS_SYMBIAN)
    // If the version of Qt on the device is < 4.7.2, that attribute won't work
    if (orientation != ScreenOrientationAuto) {
        const QStringList v = QString::fromAscii(qVersion()).split(QLatin1Char('.'));
        if (v.count() == 3 && (v.at(0).toInt() << 16 | v.at(1).toInt() << 8 | v.at(2).toInt()) < 0x040702) {
            qWarning("Screen orientation locking only supported with Qt 4.7.2 and above");
            return;
        }
    }
#endif // Q_OS_SYMBIAN

    Qt::WidgetAttribute attribute;
    switch (orientation) {
#if QT_VERSION < 0x040702
    // Qt < 4.7.2 does not yet have the Qt::WA_*Orientation attributes
    case ScreenOrientationLockPortrait:
        attribute = static_cast<Qt::WidgetAttribute>(128);
        break;
    case ScreenOrientationLockLandscape:
        attribute = static_cast<Qt::WidgetAttribute>(129);
        break;
    default:
    case ScreenOrientationAuto:
        attribute = static_cast<Qt::WidgetAttribute>(130);
        break;
#else // QT_VERSION < 0x040702
    case ScreenOrientationLockPortrait:
        attribute = Qt::WA_LockPortraitOrientation;
        break;
    case ScreenOrientationLockLandscape:
        attribute = Qt::WA_LockLandscapeOrientation;
        break;
    default:
    case ScreenOrientationAuto:
        attribute = Qt::WA_AutoOrientation;
        break;
#endif // QT_VERSION < 0x040702
    };
    setAttribute(attribute, true);
}

void MainWindow::showExpanded()
{
#ifdef Q_WS_MAC
    show();
#else
    showFullScreen();
#endif
}
